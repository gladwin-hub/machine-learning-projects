# -*- coding: utf-8 -*-
"""diabetic_prediction_with_a_simple_Neural_Network_(NN).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11R9hw1hKuLbuj-WWZpOUou6e4X28CCxo
"""

import pandas as pd
from sklearn.model_selection import train_test_split
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

df=pd.read_csv('/content/diabetes.csv')

df.head()

df.info()

df.describe()

df.groupby('Outcome').mean()

df.isna().sum()

x=df.drop('Outcome',axis=1)
y=df['Outcome']
scaler=StandardScaler()
x=scaler.fit_transform(x)

print(x)

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=42)
x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=42)
model=keras.Sequential([ layers.BatchNormalization(),
                         layers.Dense(8,activation='relu',input_shape=(8,)),
                         layers.BatchNormalization(),
                         layers.Dense(8,activation='relu'),
                         layers.BatchNormalization(),
                         layers.Dense(8,activation='relu'),
                         layers.BatchNormalization(),
                         layers.Dense(1, activation='sigmoid')])

model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['binary_accuracy'])
from keras.callbacks import EarlyStopping
early_stopping = EarlyStopping(monitor='val_loss', patience=10)

history = model.fit(x_train, y_train, validation_split=0.1, epochs=10)

plt.plot(history.history['binary_accuracy'])
plt.plot(history.history['val_binary_accuracy'])
plt.title('model_accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])

plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')

loss, accuracy = model.evaluate(x_test,y_test)
print(accuracy)

Y_pred = (model.predict(x_test) > 0.5).astype("int32")
print(Y_pred)

input_data = (4, 171, 72, 0, 0, 43.6, 0.479, 26)
input_data_np = np.asarray(input_data).reshape(1, -1)
input_data_scaled = scaler.transform(input_data_np)
prediction = model.predict(input_data_scaled)
print(f"Prediction: {prediction}")
pred = (model.predict(prediction) > 0.5).astype("int32")
print(pred)

